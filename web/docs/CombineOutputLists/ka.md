## OutputLists-ის კომბინაციები

![OutputLists Combinations](CombineOutputLists/CombineOutputLists.png)

(ComfyUI workflow ჩამოთვლილია)

4 სანამ არა მეტი OutputLists-ის მიღება და მათი ყველა კომბინაციის გენერირება.

მაგალითი: `[1, 2, 3] x ["A", "B"] = [(1, "A"), (1, "B"), (2, "A"), (2, "B"), (3, "A"), (3, "B")]`

`unzip_a` .. `unzip_d` იყენებს `is_output_list=True` (აღნიშნულია სიმბოლოით `𝌠`) და მათ შეესაბამება შესაბამისი ნოდების მიერ მიმდევრობით დამუშავება.

ყველა სია არასავალდებულოა და ცარიელი სიები იგნორდება.

ტექნიკურად ის გამოთვლის *Cartesian product*-ს და იძლევა თითოეული კომბინაციის ელემენტებად განაყოფილებულ შედეგს (`unzip`), ხოლო ცარიელი სიები შეიცვლება `None`-ით და იგი იგზავნის `None`-ს შესაბამის გამომავალზე.

მაგალითი: `[1, 2] x [] x ["A", "B"] x [] = [(1, None, "A", None), (1, None, "B", None), (2, None, "A", None), (2, None, "B", None)]`

### შეყვანები

| სახელი | ტიპი | აღწერა |
| --- | --- | --- |
| `list_a` | `*` | (არასავალდებულო) |
| `list_b` | `*` | (არასავალდებულო) |
| `list_c` | `*` | (არასავალდებულო) |
| `list_d` | `*` | (არასავალდებულო) |

### გამოყვანები

| სახელი | ტიპი | აღწერა |
| --- | --- | --- |
| `unzip_a` | `* 𝌠` | კომბინაციების მნიშვნელობა `list_a`-ს შესაბამისად. |
| `unzip_b` | `* 𝌠` | კომბინაციების მნიშვნელობა `list_b`-ს შესაბამისად. |
| `unzip_c` | `* 𝌠` | კომბინაციების მნიშვნელობა `list_c`-ს შესაბამისად. |
| `unzip_d` | `* 𝌠` | კომბინაციების მნიშვნელობა `list_d`-ს შესაბამისად. |
| `index` | `INT 𝌠` | 0..count შუალედი, რომელიც შეიძლება იყოს ინდექსის სახით გამოყენებული. |
| `count` | `INT` | სულ კომბინაციების რიცხვი. |

